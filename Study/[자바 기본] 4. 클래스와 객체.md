# [자바 기본] 4. 클래스와 객체

### 4.1 객체 지향과 자바

**객체 지향 언어의 목적**

1. 소프트웨어의 생산성 향상
2. 실세계에 대한 쉬운 모델링



**절차 지향 프로그래밍과 객체 지향 프로그래밍**

 절차 지향 프로그래밍 : 실행하고자 하는 절차대로 일련의 명령어를 나열하여 프로그래밍하는 방법

 객체 지향 프로그래밍 : 실제 세상에 가깝게 모델링하여 실제 세상의 물체를 객체로 표현하고, 이 객체들의 관계, 상호 작용을 프로그램으로 나타내는 프로그래밍 방법



**객체 지향 언어의 특성**

- 캡슐화

 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 하는 것을 말한다.

 객체는 메소드와 필드로 구성되어 있으며, 클래스라는 캡슐을 사용하여 객체를 표현하며 메소드와 필드를 클래스 내에 구현한다. 이렇게 함으로써 객체 외부에서는 객체 내의 숨겨놓은 메소드나 필드를 직접 접근할 수 없으며 메소드의 구현 내용도 알수 없다. 몇몇 메소드와 필드는 **객체 외부와의 인터페이스**를 위해 노출한다.

 즉, **보안, 보호, 외부 접근 제한**을 목적으로 하고, 외부에서 클래스 내부의 데이터를 접근 금지하는 것을 **정보 은닉화**라고 한다.

- 상속

 자바에서 상속은 **부모 클래스**의 속성을 **자식 클래스**가 물려받는 개념이다. 

슈퍼 클래스 : 부모 클래스

서브 클래스 : 자식 클래스

상속을 통해서 중복 작성을 방지하고, 코드의 재사용을 가능하게 한다.

- 다형성

 다형성은 같은 이름의 메소드 호출에 대해 객체에 따라 다른 동작을 할 수 있도록 구현되는 것을 의미한다.



### 4.2 클래스 선언과 활용

클래스 : 객체를 생성하기 위한 설계도 또는 틀

객체 == 인스턴스 : 클래스를 통해 생성된 실체



**클래스의 구성**

- 클래스 접근 권한
- class 클래스명
- 필드 : 값을 저장할 멤버 변수
- 생성자 : 클래스의 이름과 동일한 메소드 / 객체를 생성할 때만 호출됨
- 메소드 : 실행 가능한 함수



**객체 생성과 레퍼런스 변수**

- 클래스의 레퍼런스 변수 선언

```java
Person aPerson; // 레퍼런스 변수 aPerson 선언, 레퍼런스 변수가 생성된것이지 실제 객체가 생성된것이 아님을 주의하자
```

- 객체 생성, new 연산자 이용

```java
aPerson = new Person("김민섭");
```

객체가 생성되는 순서는 

1. Person타입의 객체 메모리 공간 확보
2. Person 생성자가 실행되어 name 필드의 값에 파라미터값을 설정



**객체 멤버 접근** : 객체의 멤버에 접근할 떄는 점(.) 연산자를 붙인다.

```java
객체 레퍼런스.멤버
aPerson.age = 30;
```



**객체 배열**

**객체 배열**이란 객체에 대한 레퍼런스를 원소로 갖는 배열이다.

- 배열에 대한 레퍼런스 선언

  ```java
  Person[] pa;
  Person[10] pa; //다음과 같이 레퍼런스 변수를 선언시에 원소 갯수를 설정하는 것은 오류다.
  ```

- 레퍼런스 배열 생성

```java
pa = new Person[10];
```



### 4.3 메소드의 활용

**메소드 형식**

- 접근 지정자
- 리턴 타입
- 메소드 이름과 인자, 코드



**인자 전달, call by value**

- 기본 타입이 인자로 전달되는 경우

자바 기본 타입(8가지)가 인자로 정달되는 경우에는 호출자가 건제는 인자의 값을 복사하여 메소드의 인자에 전달한다. 

- 객체 레퍼런스가 인자로 전달되는 경우

메소드 인자로 객체에 대한 레퍼런스가 전달되는 경우 레퍼런스 값만(주소값) 복사되어 전달된다.

- 배열이 인자로 전달되는 경우

배열에 대한 레퍼런스만 전달된다.



**메소드 오버로딩** : 한 클래스 내에서 이름은 같지만 인자의 타입이나 개수가 서로 다른 여러개의 메소드를 중복 작성하는 것

- 메소드 이름이 동일하여야 한다.
- 메소드 인자의 개수가 서로 다르거나, 메소드 인자의 타입이 서로 달라야 한다.
- 메소드의 이름이 같고 인자의 개수나 타입이 모두 같은데 메소드의 리턴 타입이 다르면 메소드 오버로딩이 성립되지 않으며 컴파일 오류가 발생한다.



**this**

**this**는 자바의 중요한 키워드로서 단어가 의미하는데로 객체 자신을 가리킨다. 자바에서 this는 현재 실행되는 메소드가 속한 객체에 대한 레퍼런스이다. 



### 4.4 생성자

생성자는 객체가 생성될 때 초기화를 위해 실행되는 메소드이다.



**생성자 선언과 호출**

- 생성자의 이름은 클래스 이름과 동일하다.
- 생성자는 new를 통해 객체를 생성할 떄문 호출된다.
- 생성자도 오버로딩이 가능하다.
- 생선자는 리턴 타입을 지정할 수 없다.



**기본생성자**

기본생성자란 인자도 없고 실행 내용도 없이 단순 리턴하는 생성자이다. 따라서 **디폴트 생성자**라고도 부른다.

- 기본 생성자가 자동으로 생성되는 경우

생성자가 없는 클래스는 없다. 만약 생성자가 선언되어 있지 않다면 컴파일러가 기본 생성자를 자동으로 생성한다.

- 기본생성자가 자동으로 생성되지 않는 경우

생성자가 하나라도 존재하는 클래스에서는 자동으로 생성자가 삽입되지 않는다.



**this(), 다른 생성자 호출**

한 클래스 내에서 한 생성자에서 다른 생성자를 호출할 때 사용하는 코드이다.   

예시)

```java
public class Book{
	String title;
	Stirng author;
	int ISBN;
	
	public Book(String title, String author, int ISBN){
		this.title = title;
		this.author = author;
		this.ISBN = ISBN;
	}
	
	public Book(String title, int ISBN){
		this(title, "Anonymous", ISBN);
	}
	
	public Book(){
		this(null,null,0);
		System.out.println("생성자가 호출되었음");
	}
	public static void main(String[] args){
		Book javaBook = new Book("JAVA", "황기태", 3333);
		Book holyBible = new Book("Holy Bible", 1);
		Book emptyBook = new Book();
	}
}
```

- this()는 생성자 코드에서만 사용할 수 있다.
- this()는 동일한 클래스 내의 다른 생상자를 호출할 떄 사용한다.
- this()는 반드시 생성자의 첫 번째 문장에서 사용되어야 한다.



**객체의 소멸**

객체 소멸이란 new에 의해 생성된 객체 메모리를 자바 가상 기계에게 돌려주어 가용 메모리에 포함시키는 것이다.

자바는 **가비지 컬렉터**에 의해 필요없는 메모리를 수거하며 따라서 자바는 소멸자가 없다.



### 4.5 가비지와 가비지 컬렉션

**가비지** : 응용프로그램에서 더 이상 사용되지 않는 메모리이다. 더이상 사용하지 않는다는 뜻은 객체나 배열을 가리키는 래퍼런스가 하나도 없음을 의미한다.



**가비지 컬렉션 **: 자바 가상 기계는 가용 공간이 일정 크기 이하로 줄어들게 되면 자동으로 가비지를 회수하여 가용 메모리 공간을 늘린다.



**가비지 컬렉터** : 가비지 컬렉션을 수행하는 주체이며, 가비지 컬렉터가 언제 일어나는지는 알기 어렵다.



**가비지 컬렉션 강제 수행**

```java
System.gc(); //가비지 컬렉션 작동 요청
```



### 4.6 접근 지정자

#### 클래스 접근 지정자

- public : 모든 패키지에서 접근 가능
- default : 다른 패키지에서 접근 불가



#### 멤버 접근 지정자

멤버 : 필드와 메소드

| 멤버에 접근하는 클래스 | default | private | protected | public |
| :--------------------: | :-----: | :-----: | :-------: | :----: |
|  같은 패키지의 클래스  |    O    |    X    |     O     |   O    |
|  다른 패키지의 클래스  |    X    |    X    |     X     |   O    |



### 4.7 static 멤버

객체를 생성하지 않고도 사용할 수 있는 멤버를 static멤버라고 부른다.

static멤버는 클래스당 하나만 생성되는 멤버이다.  



**static 멤버 사용 1 : 객체.static 멤버**

static멤버도 역시 멤버이기 때문에 다음과 같이 일반적인 멤버 사용법과 다를바 없다.

```java
객체.static필드
객체.static메소드
```

static 멤버가 생성되는 시점은 main() 메소드가 실행을 시작한 후 StaticSample이 등장하는 시점이다. 따라서 레퍼런스 변수 선언 이전부터 static멤버는 이미 존재하며 사용가능하다.



**static 멤버 사용 2 : 클래스명.static멤버**

static멤버는 클래스당 하나만 있기 때문에 다음과 같이 클래스 이름으로 바로 접근이 가능하다.

```java
클래스명.static멤버
```

ex)

```java
Math.abs()
```



**static의 활용**

- 전역 변수와 전역 함수를 만들때 활용

자바에서는 캡슐화의 원칙때문에 어떤 변수나 함수도 클래스 밖에서 존재 할 수 없기때문에, 전역 함수 혹은 전역 변수를 만들기 위해 사용한다.

- 공유 멤버를 만들고자 할 때 활용



**static 메소드의 제약 조건**

- static메소드는 오직 static멤버만 접근 할 수 있다.

왜냐하면 static메소드는 객체가 생성되지 않은 시점에서도 사용할 수 있기때문이다.

- static메소드에서는 this 키워드를 사용할 수 없다.

static메소드는 객체가 생성되지 않은 상황에서도 클래스 이름을 이용하여 호출이 가능하기 때문에 호출 당시 실행중인 객체를 가리키는 this 레퍼런스를 사용할 수 없다.



### 4.8 final

final 키워드가 사용될 수 있는 곳은 세군데 이다.

#### final 클래스

클래스에 final이 붙으면 상속 받을 수 없음을 의미한다.



#### final 메소드

오버라이딩이 불가능하게 할 수 있다.



#### final 필드, 상수 정의

- 상수 필드는 선언시에 초깃값을 지정하여야 한다. 그리고 한번 정의 되면 바꿀 수 없다.
- public static final로 프로그램 전체에서 공유하여 사용하는 상수로 만들 수 있다.