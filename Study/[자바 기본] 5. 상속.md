# [자바 기본] 5. 상속

### 5.1 상속의 개념

**상속의 필요성** 

- 클래스 사이의 멤버 중복 선언 불필요

- 필드와 메소드 재사용으로 클래스 간결화
- 클래스 간 계층적 분류 및 관리



**상속관계**

SuperClass <---(상속)---- SubClass



### 5.2 클래스 상속과 객체

**상속 키워드** : extends



**상속의 특징**

- 다중상속을 지원하지 않는다.

하나의 클래스가 여러개를 동시에 상속받지 못한다. 즉 extends 뒤에는 오직 하나의 클래스 이름만 온다.

- 상속횟수의 제한은 없다.
- 모든 클래스는 Object클래스를 자동으로 상속받고, 오직 Object클래스만이 슈퍼 크래스를 가지고 있지 않다.



### 5.3 상속과 접근 지정자

|                        | default | private | protected | public |
| :--------------------: | :-----: | ------- | --------- | ------ |
|   같은 패키지 클래스   |    O    |         |           |        |
| 같은 패키지 서브클래스 |         |         | O         |        |
|   다른 패키지 클래스   |         |         |           |        |
| 다른 패키지 서브클래스 |         |         |           |        |

*인스턴스 == 객체



### 5.4 상속과 생성자

**서브클래스와 슈퍼클래스의 생성자 호출 및 실행관계**

서브클래스가 인스턴스화할때 생성자를 호출하는데 이는 상속받은 슈퍼클래스의 멤버들을 사용할 수 있어야하기때문에 다시 슈퍼 클래스의 생성자를 호출한다. 따라서 최상위 슈퍼클래스의 생성자까지 호출이 간다면 생성자의 실행은 최상위부터 호출을 한 서브 클래스 순으로 생성자가 실행된다.



- 슈퍼클래스와 서브클래스의 생성자 조합

  |            |     1      |       2        |       3        |       4        |
  | :--------: | :--------: | :------------: | :------------: | :------------: |
  | 서브클래스 | 기본생성자 | 매개변수생성자 |   기본생성자   | 매개변수생성자 |
  | 슈퍼클래스 | 기본생성자 |   기본생성자   | 매개변수생성자 | 매개변수생성자 |

이럴때 특별하지 않은 경우에는 **서브클래스 생성자의 관계없이 ** 슈퍼클래스의 **기본 생성자**가 선택된다.

단, 서브클래스에서 매개변수 생성자를 호출하면 상위 클래스에는 기본생성자가 이미 구현되어 있어야한다.

상위 클래스의 매개변수 생성자를 선택하여 호출하고싶으면 서브클래스의 매개변수 생성자에 super(매개변수); 를 실행하면 super안에 있는 매개변수에 짝지 맞는 슈퍼클래스의 매개변수생성자를 찾아 호출한다.

물론 super() 에 매개변수가 전달되지 않으면 기본생성자를 호출한다.



### 5.5 객체의 타입 변환 : 업캐스팅과 다운캐스팅

*캐스팅 : 강제 타입 변환



**업캐스팅**

서브클래스가 슈퍼클래스로 타입 변환하는 것.

사람이 생물이라고 불리는 것과 같은 이치.

즉, 서브클래스의 인스턴스가 업캐스팅된다면, 슈퍼클래스가 가지고있던 필드만 접근가능하다.



**다운캐스팅**

슈퍼클래스가 서브클래스로 타입 변환하는 것.

업캐스팅 된것을 다시 돌리는 것을 다운캐스팅이라고 한다.



업캐스팅된 경우 인스턴스의 실제 클래스타입을 모를수가있다. 따서 **instanceof**연산자를 사용한다.

```
객체 레퍼스 instanceof 클래스타입   // 리턴값은 boolean
```



### 5.6 메소드 오버라이딩

메소드 오버라이딩은 슈퍼클래스와 서브클래스 사이에서 발생하는 관계이다.

즉,  슈퍼클래스의 메소드를 서브클래스에서 동일한 이름으로 재작성하는 것이다. 단 슈퍼클래스의 메소드와 **같은 이름, 같은 리턴타입, 같은 매개변수**를 갖는다.



서브클래스가 업캐스팅 된경우에 메소드를 호출하면 원래의 클래스에서 가지고 있던 메소드를 **동적바인딩**으로 호출한다.



**@Override** : 슈퍼클래스의 메소드를 서브클래스에서 오버라이딩 하는 것이니 컴파일러에게 제대로 확인하라는 것을 명령하는 애노테이션



**오버라이딩의 조건**

- 메소드 오버라이딩은 슈퍼클래스의 메소드와 완전히 동일한 메소드를 재정의한다.

같은 이름, 같은 리턴 타입, 같은 매개 변수 리스트

- 메소드 오버라이딩시에는 슈퍼클래스 메소드의 접근 지정자보다 접근 범위가 좁아질 수 없다.

접근 범위 : public   >   protected   >   default   >   private

- static, private, final로 선언한 메소드는 오버라이딩 불가



**super** : 슈퍼 클래스에 대한 래퍼런스로, 이것을 통해 super클래스의 필드와 메소드레 접근 가능   



### 5.7 추상 클래스

*abstract : 추상 키워드

**추상메소드** : 메소드 이름, 타입, 매개변수만 선언되있는 메소드 //코드가 들어가면 안된다.



**추상 클래스**

1. 추상메소드를 가진 추상클래스
2. 추상메소드가 없는 추상글래스



**추상클래스**는 따라서 인스턴스를 생성할 수 없다.

 따라서 추상클래스로 부터 받은 추상메소드들을 오버라이딩해야지 클래스가 될 수 있고, 오버라이딩하지 않는다면 클래스앞에 abstract를 명시해야한다. 

즉 추상 클래스는 앞으로 이것을 상속받아 구현할 클래스들의 뼈대가 된다.



### 5.8 인터페이스

*interface

**인터페이스의 특징**

1. 멤버로 추상 메소드와 상수만 가진다.  //abstract 생략가능
2. 모든 메소드는 접근지정자가 public이다. //생략가능
3. 상수도 public static final 생략가능
4. 객체생성 할 수 없다.
5. 다른 인터페이스에 상속될 수 있다.
6. 객체는 만들지 못하지만 래퍼런스 변수를 만드는것은 가능 ex) Clock clock;  (Clock 인터페이스)



**인터페이스 상속**

클래스는 인터페이스를 상속받을수 없다. 오직 인터페이스만 상속이 가능하다. 따라서 **다중상속가능**

// 클래스 : 다중상속 불가능 / 인터페이스 : 다중상속가능  상속의 키워드는 **extends**

이렇게 인터페이스든 혹은 다른 여러 인터페이스를 상속받은 인터페이스를 구현하여 클래스화 할 수 있다.

이때는 **implements**라는 키워들 사용한다.

단 interface내에있는 메소드는 모두 추상메소드이기 때문에 오버라이드 해야한다.

**인터페이스 다중 구현**

클래스는 하나 이상의 인터페이스를 구현이 가능하며, 모든 인터페이스의 추상메소드를 구현해야한다.



#### 인터페이스와 추상 클래스

|    비교     |                             내용                             |
| :---------: | :----------------------------------------------------------: |
| 추상 클래스 | - 일반 메소드 포함 가능<br />- 상수, 변수 필드 포함 가능<br />- 모든 서브 클래스에 공통된 메소드가있는 경우 추상클래스가 적합 |
| 인터페이스  | - 모든 메소드가 추상메소드<br />-상수 필드만 포함 가능<br />- 다중 상속 지원 |

